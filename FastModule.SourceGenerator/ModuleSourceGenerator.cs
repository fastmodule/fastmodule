namespace FastModule.SourceGenerator;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Generic;
using System.Linq;
using System.Text;

[Generator]
public class ModuleSourceGenerator : ISourceGenerator
{
    public void Initialize(GeneratorInitializationContext context)
    {
        // Register a syntax receiver to find classes implementing IModule
        context.RegisterForSyntaxNotifications(() => new ModuleSyntaxReceiver());
    }

    public void Execute(GeneratorExecutionContext context)
    {
        // Get the syntax receiver
        if (context.SyntaxReceiver is not ModuleSyntaxReceiver receiver)
            return;

        // Get the compilation
        var compilation = context.Compilation;

        // Get the IModule symbol
        var moduleInterface = compilation.GetTypeByMetadataName("FastModule.IModule");
        if (moduleInterface == null)
            return;

        // Find all classes implementing IModule
        var moduleClasses = new List<INamedTypeSymbol>();
        foreach (var classDeclaration in receiver.CandidateClasses)
        {
            var model = compilation.GetSemanticModel(classDeclaration.SyntaxTree);
            var typeSymbol = model.GetDeclaredSymbol(classDeclaration) as INamedTypeSymbol;
            if (typeSymbol != null && typeSymbol.AllInterfaces.Contains(moduleInterface))
            {
                moduleClasses.Add(typeSymbol);
            }
        }

        // Generate the registration and mapping code
        if (moduleClasses.Any())
        {
            var sourceCode = GenerateRegistrationAndMappingCode(moduleClasses);
            context.AddSource("ModuleRegistration.g.cs", SourceText.From(sourceCode, Encoding.UTF8));
        }
    }

    private string GenerateRegistrationAndMappingCode(List<INamedTypeSymbol> moduleClasses)
    {
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("using Microsoft.AspNetCore.Builder;");
        sb.AppendLine("using Microsoft.Extensions.DependencyInjection;");
        sb.AppendLine();
        sb.AppendLine("public static class ModuleRegistration");
        sb.AppendLine("{");
        sb.AppendLine("    public static IServiceCollection RegisterModules(this IServiceCollection services)");
        sb.AppendLine("    {");

        foreach (var moduleClass in moduleClasses)
        {
            sb.AppendLine($"        services.AddSingleton<IModule, {moduleClass.Name}>();");
        }

        sb.AppendLine("        return services;");
        sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine("    public static IEndpointRouteBuilder MapModules(this IEndpointRouteBuilder endpoints)");
        sb.AppendLine("    {");

        foreach (var moduleClass in moduleClasses)
        {
            sb.AppendLine($"        new {moduleClass.Name}().MapEndpoints(endpoints);");
        }

        sb.AppendLine("        return endpoints;");
        sb.AppendLine("    }");
        sb.AppendLine("}");

        return sb.ToString();
    }
}

// Syntax receiver to find classes implementing IModule
public class ModuleSyntaxReceiver : ISyntaxReceiver
{
    public List<ClassDeclarationSyntax> CandidateClasses { get; } = new();

    public void OnVisitSyntaxNode(SyntaxNode syntaxNode)
    {
        if (syntaxNode is ClassDeclarationSyntax classDeclaration &&
            classDeclaration.BaseList?.Types.Any(t => t.Type.ToString() == "IModule") == true)
        {
            CandidateClasses.Add(classDeclaration);
        }
    }
}