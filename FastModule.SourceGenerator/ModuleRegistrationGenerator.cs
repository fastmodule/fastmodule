namespace FastModule.SourceGenerator;

using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

/// <summary>
/// Source generator for FastModule module registration and mapping.
/// </summary>
[Generator]
public class ModuleRegistrationGenerator : ISourceGenerator
{
    public void Initialize(GeneratorInitializationContext context)
    {
        context.RegisterForSyntaxNotifications(() => new ModuleSyntaxReceiver());
    }

    public void Execute(GeneratorExecutionContext context)
    {
        if (context.SyntaxReceiver is not ModuleSyntaxReceiver receiver)
            return;

        // Get compilation and all syntax trees
        Compilation compilation = context.Compilation;

        // Collect IModule implementations
        var moduleTypes = new List<INamedTypeSymbol>();
        foreach (var classDeclaration in receiver.CandidateClasses)
        {
            SemanticModel semanticModel = compilation.GetSemanticModel(classDeclaration.SyntaxTree);
            if (
                semanticModel.GetDeclaredSymbol(classDeclaration)
                is not INamedTypeSymbol classSymbol
            )
                continue;

            if (ImplementsIModule(classSymbol, compilation))
            {
                moduleTypes.Add(classSymbol);
            }
        }

        if (moduleTypes.Count == 0)
        {
            // No modules found, no need to generate anything.
            return;
        }

        // Generate the registration code
        string registrationCode = GenerateRegistrationCode(
            moduleTypes,
            context.Compilation.AssemblyName ?? "MyProject"
        );

        // Add the generated source to the compilation
        context.AddSource(
            "ModuleRegistration.g.cs",
            SourceText.From(registrationCode, Encoding.UTF8)
        );
    }

    private static bool ImplementsIModule(INamedTypeSymbol typeSymbol, Compilation compilation)
    {
        var iModuleType = compilation.GetTypeByMetadataName("FastModule.Core.IModule");
        if (iModuleType == null)
            return false; // IModule not found.  Important for cases where the core library isn't referenced.

        return typeSymbol.AllInterfaces.Contains(iModuleType);
    }

    private static string GenerateRegistrationCode(
        List<INamedTypeSymbol> moduleTypes,
        string assemblyName
    )
    {
        StringBuilder sb = new StringBuilder();

        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("using Microsoft.Extensions.DependencyInjection;");
        sb.AppendLine("using Microsoft.AspNetCore.Routing;");
        sb.AppendLine("using FastModule.Core;");
        sb.AppendLine("using System;");
        sb.AppendLine("namespace FastModule.Generated"); // Namespace to avoid conflicts

        sb.AppendLine("{");
        sb.AppendLine(
            $"    public static class ModuleRegistrationExtensions_{assemblyName.Replace(".", "_")}"
        ); // Class name depends on assembly name to avoid conflicts
        sb.AppendLine("    {");

        sb.AppendLine(
            "        public static IServiceCollection AddGeneratedModules(this IServiceCollection services)"
        );
        sb.AppendLine("        {");

        if (moduleTypes.Count > 0)
        {
            sb.AppendLine("            ModuleManager.RegisterModules(services,");
            sb.AppendLine(
                "                "
                    + string.Join(
                        ",\n                ",
                        moduleTypes.Select(m => $"typeof({m.ToDisplayString()})")
                    )
                    + ");"
            );
        }
        else
        {
            sb.AppendLine("            // No modules found to register.");
        }

        sb.AppendLine("            return services;");
        sb.AppendLine("        }");

        sb.AppendLine(
            "        public static IEndpointRouteBuilder MapGeneratedModules(this IEndpointRouteBuilder endpoints)"
        );
        sb.AppendLine("        {");

        if (moduleTypes.Count > 0)
        {
            sb.AppendLine("            ModuleManager.MapModules(endpoints,");
            sb.AppendLine(
                "                "
                    + string.Join(
                        ",\n                ",
                        moduleTypes.Select(m => $"typeof({m.ToDisplayString()})")
                    )
                    + ");"
            );
        }
        else
        {
            sb.AppendLine("            // No modules found to map endpoints.");
        }

        sb.AppendLine("            return endpoints;");
        sb.AppendLine("        }");

        sb.AppendLine("    }");
        sb.AppendLine("}");

        return sb.ToString();
    }

    class ModuleSyntaxReceiver : ISyntaxReceiver
    {
        public List<ClassDeclarationSyntax> CandidateClasses { get; } =
            new List<ClassDeclarationSyntax>();

        public void OnVisitSyntaxNode(SyntaxNode syntaxNode)
        {
            if (
                syntaxNode is ClassDeclarationSyntax classDeclaration
                && classDeclaration.BaseList != null
            )
            {
                CandidateClasses.Add(classDeclaration);
            }
        }
    }
}
